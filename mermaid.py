"""Generate Mermaid diagram from CSV product list.

Mostly generated by a LLM.
"""

import csv
import argparse
from collections import defaultdict
from typing import Dict, List, Tuple


def read_csv_file(filename: str) -> List[Dict]:
    """Read CSV file and return list of product dictionaries."""
    products = []
    try:
        with open(filename, 'r', encoding='utf-8') as file:
            reader = csv.DictReader(file, delimiter=';')
            for row in reader:
                products.append(row)
    except FileNotFoundError:
        raise FileNotFoundError(f"CSV file '{filename}' not found.")
    except Exception as e:
        raise Exception(f"Error reading CSV file: {e}")

    return products


def validate_dependencies(products: List[Dict]) -> None:
    """Validate that all dependencies exist in the product list."""
    # Create set of existing products (short_name, product_type)
    existing_products = set()
    for product in products:
        key = (product['short_name'], product['product_type'])
        existing_products.add(key)

    # Check dependencies
    for product in products:
        if product['dependencies'].strip():
            deps = [dep.strip() for dep in product['dependencies'].split(',')]
            for dep in deps:
                if '/' in dep:
                    short_name, product_type = dep.split('/')
                    dep_key = (short_name, product_type)
                    if dep_key not in existing_products:
                        raise ValueError(
                            f"Dependency '{dep}' for product {product['short_name']}/{product['product_type']} does not exist.")


def get_node_id(short_name: str, product_type: str) -> str:
    """Generate unique node ID for mermaid diagram."""
    return f"{short_name}_{product_type}"


def get_node_shape(product_type: str) -> Tuple[str, str]:
    """Get node shape based on product type."""
    if product_type in ['CDR', 'NORMAL']:
        return '[(', ')]'  # Database symbol
    elif product_type in ['ICDR', 'ANOMALY']:
        return '[', ']'  # Rectangle
    else:
        return '[', ']'  # Default rectangle


def get_class_def(creator: str) -> str:
    """Get class definition based on creator."""
    creator_mapping = {
        "ACSAF": "ac",
        'CMSAF': 'cm',
        "HSAF": "h",
        "LSASAF": "lsa",
        "NWCSAF": "nwc",
        "NWPSAF": "nwp",
        'OSISAF': 'osi',
        "ROMSAF": "rom",
        'EUMETSAT': 'eum',
        'EXTERNAL': 'ext'
    }
    return creator_mapping.get(creator, 'ext')


def generate_mermaid_diagram(products: List[Dict]) -> str:
    """Generate Mermaid diagram code from product data."""
    validate_dependencies(products)

    # Group products by family
    families = defaultdict(list)
    for product in products:
        families[product['product_family']].append(product)

    # Start building the diagram
    lines = ['flowchart TD']

    # Generate subgraphs for each product family
    for family_name, family_products in families.items():
        lines.append(f'    subgraph {family_name.replace(" ", "_")}["{family_name}"]')

        # Add nodes within subgraph
        for product in family_products:
            node_id = get_node_id(product['short_name'], product['product_type'])
            shape_start, shape_end = get_node_shape(product['product_type'])
            label = f"{product['product_id']}<br/>{product['long_name']}"
            lines.append(f'        {node_id}{shape_start}"{label}"{shape_end}')

        lines.append('    end')
        lines.append('')

    # Add dependencies (arrows)
    for product in products:
        if product['dependencies'].strip():
            target_id = get_node_id(product['short_name'], product['product_type'])
            deps = [dep.strip() for dep in product['dependencies'].split(',')]

            for dep in deps:
                if '/' in dep:
                    dep_short_name, dep_product_type = dep.split('/')
                    source_id = get_node_id(dep_short_name, dep_product_type)
                    lines.append(f'    {source_id} --> {target_id}')

    lines.append('')

    # Add class definitions
    lines.extend([
        '    classDef ac fill:#ae8cbf, color:#000',
        '    classDef cm fill:#fece79, color:#000',
        '    classDef h fill:#4da8ba, color:#000',
        '    classDef lsa fill:#f79b6a, color:#000',
        '    classDef nwc fill:#beddf2, color:#000',
        '    classDef nwp fill:#d2c4de, color:#000',
        '    classDef osi fill:#67d0f7, color:#000',
        '    classDef rom fill:#a3c179, color:#000',
        '    classDef eum fill:#507891, color:#000',
        '    classDef ext fill:#bbbbbb, color:#000',
        '    classDef sub fill:#f5f5f5',
        ''
    ])

    # Apply classes to nodes
    for product in products:
        node_id = get_node_id(product['short_name'], product['product_type'])
        class_name = get_class_def(product['creator'])
        lines.append(f'    class {node_id} {class_name}')

    # Apply sub class to subgraphs
    for family_name in families.keys():
        subgraph_id = family_name.replace(" ", "_")
        lines.append(f'    class {subgraph_id} sub')

    return '\n'.join(lines)


def main():
    """Main function to generate Mermaid diagram from CSV."""
    parser = argparse.ArgumentParser(
        description='Generate Mermaid diagram from CSV product list')
    parser.add_argument(
        'csv_file',
        help='CSV product list'
    )
    parser.add_argument(
        '-o', '--output',
        help='Save diagram to the given file'
    )
    args = parser.parse_args()
    products = read_csv_file(args.csv_file)
    mermaid_code = generate_mermaid_diagram(products)
    if args.output:
        with open(args.output, 'w', encoding='utf-8') as f:
            f.write(mermaid_code)
    else:
        print(mermaid_code)


if __name__ == "__main__":
    main()